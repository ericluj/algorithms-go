# 排序

| 名称               | 代码       |
| ------------------ | ---------- |
| 选择排序           | Selection  |
| 插入排序           | Insertion  |
| 希尔排序           | Shell      |
| 自顶向下的归并排序 | Merge      |
| 自底向上的归并排序 | MergeBu    |
| 快速排序           | Quick      |
| 三向切分的快速排序 | Quick3way  |
| 基于堆的优先队列   | MaxPQ      |
| 关联索引的优先队列 | IndexMinPQ |
| 堆排序             | Heap       |

------

#### 选择排序
```
先找到数组中最小的元素，其次将它和数组第一个元素交换位置
再次，在数组剩下元素找到最小的元素，将其与第二个元素交换位置
如此往复，直到数组排序结束
```

#### 插入排序
```
按索引位置依次移动数组中元素
不停与前一位比较，若比其小，则交换位置
与选择排序不同地方在于，遍历过程中，左侧所有元素的最终位置还不确定
适用于部分有序的数组
```

#### 希尔排序
```
插入排序的改进版本
先对间隔h的逻辑数组进行插入排序，如此可以将元素移动到很远的地方，形成h有序数组
然后h不断递减至1，完成数组排序
```

#### 归并排序
```
将数组分为两个部分[lo,mid]和[mid+1,hi]，这里两个部分都是各自有序
依次从两各部分中拿出元素进行比较，较小的元素放入
若某一部分所有元素都取完，直接把另一部分剩下元素依次放入即可

自顶向下的归并排序（递归）
自底向上的归并排序（递归的反思路，for循环构造）
```

#### 快速排序
```
快速排序是当两个子数组有序时，整个数组也就自然有序了
关键地方在于切分，切分需要使满足三个条件:

1.对于某个j，nums[j]已经排定
2.nums[lo]到nums[j-1]所有元素都小于等于nums[j]
3.nums[j+1]到nums[hi]所有元素都大于等于nums[j]

切分：

1.随意取nums[lo]为切分元素
2.从左向右扫描直到一个大于等于它的元素
3.从右向左扫描直到一个小于等于它的元素
4.交换找到的两个元素
5.继续2.3.4操作，可以保证左指针i左侧都小于等于切分元素，右指针j右侧都大于等于切分元素
6.当两个指针相遇，交换切分元素nums[lo]和左子数组最右侧元素nums[j]并返回j即可
```

#### 三向切分的快速排序
```
标准快速排序在重复值较多的时候会导致效率下降
三向切分将数组分为小于、等于、大于三部分，递归中不再处理等于部分
```

#### 堆排序
```
当一棵二叉树的每个结点都大于等于它的两个子结点时，称为堆有序
数组表示二叉堆：数据中按照层级存储（索引为0的位置不使用）
位置k的结点的父结点的位置为k/2，它的两个子结点位置为2k和2k+1
通过上浮和下沉操作来构造堆有序

上浮：
如果结点k不是根结点（k==1为根结点）且结点k大于它的父结点k/2
将结点k与父结点k/2交换位置

下沉：
如果结点k不是叶子结点2*k<=p.N
如果左右子结点存在，找到子结点中较大的结点
当j==p.N说明没有右子结点
如果结点k大于它的两个子结点，无需下沉
将结点k与子结点中较大的结点交换位置

将最大元素a[1]与a[N]交换，然后修复堆，将a[1]到a[N]的元素排序
将exch()和less()实现中的索引减1即可得到与其他排序算法一致的实现
```